<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Procedural tree generation</title>
		<meta name="author" content="Paulius Bieksa">
		<meta name="description" content="Procedural generation of trees using a space colonization algorithm.">
		<!--Import Google Icon Font-->
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
		<!--Import materialize.css-->
		<link type="text/css" rel="stylesheet" href="../styles/materialize.min.css"  media="screen,projection"/>
		<link rel="stylesheet" href="../styles/main.css">
		<link rel="stylesheet" href="../styles/slideshow.css">
		<!--Let browser know website is optimized for mobile-->
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	</head>
	<body>
		<div class="container">
			<div class="row center article_title">
				<h5 id="page_title">Procedural tree generation</h5>
				<!-- Asociated tags are generated here by pages_common.js -->
				<p id="date_stamp"><time datetime="2018-12">December 2018</time></p>
			</div>
			
			<div class="row left article">
				<!-- Empty column to center the article -->
				<div class="col s0 m1 l2"></div>
				<article class="col s12 m10 l8">
					<img src="../assets/images/pcg_trees/tree2_reduced.gif">
					<h5>Introduction</h5>
					<p>Procedural content generation is a field that is very useful in certain projects. In particular, big, open world 
						games can find procedurally generated content extremely useful. Instead of having artists model hundreds of 
						variations of an asset, those variations can be generated by a program.
					</p>
					<p>This project is a proof of concept for generating realistic looking foliage - trees in particular. 
						The aim of the project is to generate a realistic looking topology of a tree. The crown or roots of the tree are 
						not	considered.	This is done using the space colonization algorithm. The algorithm treats competition for space 
						as the main factor determining branching and the structure of the tree.
					</p>
					<h5>The space colonization algorithm</h5>
					<p>The algorithm is initialized with a number of attraction points. These points, as the name suggests, attract 
						the new nodes generated in the tree structure. Once the attraction points are defined, an iterative process 
						of adding nodes to the tree structure is started:
						<ol type="I">
							<li>The closest node is found for all attraction points within predefined range</li>
							<li>Each of the nodes found as closest in previous step determine the average direction to all points 
								that found it the closest node. This is used as the direction for the growth of the next node</li>
							<li>A new node is added at a predefined distance along the direction found in step II, for each node 
								that was deemed closest by at least one attraction point</li>
							<li>All attraction point that are within a predefined kill distance to any node are removed</li>
							<li>If there are no nodes remaining or none of the remaining ones are within the radius of influence, 
								the algorithm is considered completed and is stopped</li>
						</ol>
						If this algorithm is followed as is, a small issue arises, where some two attraction points 
						in mirroring directions would affect the same node and cause the placement of the next nodes on that branch 
						to loop infinitely. When this bug was found during the development it was trivial to detect it and fix it.
					</p>
					<h5>Application work-flow</h5>
					<p>The first thing the algorithm requires is the attraction points. To this end the area of the crown of the tree 
						is defined by the user. This id done by drawing an outline of the crown on the Y-X plane by the user. 
						The application then generates the attraction points within the volume defined by the rotated outline.
					</p>
					<p>Once the crown of the tree is defined the algorithm generates the tree. This process can be seen as it is happening. 
						Once it is done, the topology of the tree is rendered using lines to represent branches. The user can then choose 
						to apply some post-processing of the tree structure to reduce the node count and generate a simple representation 
						of the body of the tree.
					</p>
					<!-- Slideshow of the application work-flow -->
					<div class="slideshow_container">
						<!-- All images -->
						<div class="slides">
							<img src="../assets/images/pcg_trees/crown_area.png">
							<div class="slide_caption">Defining the area of the crown.</div>
						</div>
						
						<div class="slides">
							<img src="../assets/images/pcg_trees/attraction_points.png">
							<div class="slide_caption">Attraction points generated in the defined area.</div>
						</div>
						
						<div class="slides">
							<img src="../assets/images/pcg_trees/debug.png">
							<div class="slide_caption">Tree shown in debug mode while being generated. Blue lines represent attraction vectors, red - vector for the placement of the next node.</div>
						</div>
						
						<div class="slides">
							<img src="../assets/images/pcg_trees/topology.png">
							<div class="slide_caption">Generated topology of the tree.</div>
						</div>
						
						<div class="slides">
							<img src="../assets/images/pcg_trees/tree_done.png">
							<div class="slide_caption">Representation of the tree using cylinders with a calculated thickness.</div>
						</div>
						
						<!-- Next and previous buttons -->
						<a class="prev" onclick="change_slide(-1, 0)">&#10094</a>
						<a class="next" onclick="change_slide(1, 0)">&#10095</a>
					</div>
					<h5>Results</h5>
					<p>The resulting application can generate some convincing tree topology. The space colonization algorithm is definitely 
						a viable algorithm for producing realistic looking trees. A wide range of different tree structures can be generated 
						by changing the control parameters.
					</p>
					<p>
						Here are some trees generated using different parameters:
					</p>
					<!-- Slideshow of different results -->
					<div class="slideshow_container">
						<!-- All images -->
						<div class="slides">
							<img src="../assets/images/pcg_trees/tree1.png">
						</div>
						<div class="slides">
							<img src="../assets/images/pcg_trees/tree2.png">
						</div>
						<div class="slides">
							<img src="../assets/images/pcg_trees/tree3.png">
						</div>
						<div class="slides">
							<img src="../assets/images/pcg_trees/tree4.png">
						</div>
						<div class="slides">
							<img src="../assets/images/pcg_trees/tree5.png">
						</div>
						<div class="slides">
							<img src="../assets/images/pcg_trees/tree6.png">
						</div>
						
						<!-- Next and previous buttons -->
						<a class="prev" onclick="change_slide(-1, 1)">&#10094</a>
						<a class="next" onclick="change_slide(1, 1)">&#10095</a>
					</div>
					
					<div class="footnote_links">
						<a target="_blank" href="https://github.com/PauliusBieksa/ProceduralTrees">Git repository</a> | 
						<a target="_blank" href="../assets/PDFs/pcg_trees.pdf">Full report</a></p>
					</div>
				</article>
			</div>
		</div>
		
		
		<!--JavaScript at end of body for optimized loading-->
		<script type="text/javascript" src="../scripts/materialize.min.js"></script>
		<script type="text/javascript" src="../assets/data/index.json"></script>
		<script type="text/javascript" src="../scripts/pages_common.js"></script>
		<script type="text/javascript" src="../scripts/slideshow.js"></script>
	</body>
</html>
